

# 정렬 

| 알고리즘 | 최선 시간 복잡도 | 평균 시간 복잡도 | 최악 시간 복잡도 | 공간 복잡도 | 안정성 | 비고 |
| --- | --- | --- | --- | --- | --- | --- |
| 버블 정렬 | O(n) | O(n^2) | O(n^2) | O(1) | 안정 | 비효율적인 경우가 많음 |
| 선택 정렬 | O(n^2) | O(n^2) | O(n^2) | O(1) | 불안정 | 간단하지만 비효율적 |
| 삽입 정렬 | O(n) | O(n^2) | O(n^2) | O(1) | 안정 | 작은 데이터 세트에서 효율적 |
| 병합 정렬 | O(n log n) | O(n log n) | O(n log n) | O(n) | 안정 | 대규모 데이터에 효율적 |
| 퀵 정렬 | O(n log n) | O(n log n) | O(n^2) | O(log n) | 불안정 | 대부분의 경우 가장 빠름 |
| 힙 정렬 | O(n log n) | O(n log n) | O(n log n) | O(1) | 불안정 | 메모리 사용량이 적음 |
| 계수 정렬 | \- | O(n + k) | O(n + k) | O(k) | 안정 | k는 입력 데이터의 범위. 작은 범위의 정수에 적합 |
| 기수 정렬 | \- | O(nk) | O(nk) | O(n + k) | 안정 | k는 숫자의 최대 자릿수. 큰 숫자에 효율적 |





- python은 sort() 또는 sorted() 함수로 정렬 가능하다 -> O(nlogn)의 시간복잡도
- 카운팅 정렬
  - 주어진 배열의 값 범위가 작은 경우 빠른 속도를 갖는 정렬 알고리즘
- sorted 다중 조건
  - f = sorted(dic.items(), key = lambda x : (x[0], -x[1]))

